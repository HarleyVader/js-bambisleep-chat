import argparse
import socket
import json
import sys
import os
from io import BytesIO
import wave
import tempfile
from http.server import HTTPServer, BaseHTTPRequestHandler
from urllib.parse import urlparse, parse_qs
import threading

# Global flag for controlling server
keep_running = True

class TTSSocketClient:
    def __init__(self, host="127.0.0.1", port=9000):
        self.host = host
        self.port = port
        self.audio_cache = {}  # Store recent audio to avoid regeneration
        print(f"TTSSocketClient initialized with server at {host}:{port}")
        
    def generate_tts(self, text, speaker_id=None, streaming=False):
        """Generate TTS audio using the F5-TTS socket server."""
        client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        try:
            print(f"Connecting to F5-TTS at {self.host}:{self.port}")
            client.connect((self.host, self.port))
            
            request = {
                "text": text,
                "streaming": streaming
            }
            if speaker_id is not None:
                request["speaker_id"] = speaker_id
            
            print(f"Sending request: {json.dumps(request)}")
            client.sendall(json.dumps(request).encode() + b"\n")
            
            # Receive response
            audio_data = b""
            while True:
                chunk = client.recv(4096)
                if not chunk:
                    break
                audio_data += chunk
            
            print(f"Received {len(audio_data)} bytes of audio data")
            return audio_data
            
        except Exception as e:
            print(f"Error generating TTS: {e}")
            return None
        finally:
            client.close()
    
    def create_wav_data(self, audio_data):
        """Convert raw audio data to WAV format without saving to file."""
        if not audio_data:
            return None
            
        # Create WAV data in memory
        wav_io = BytesIO()
        with wave.open(wav_io, "wb") as wav_file:
            wav_file.setnchannels(1)
            wav_file.setsampwidth(2)
            wav_file.setframerate(24000)
            wav_file.writeframes(audio_data)
        return wav_io.getvalue()
    
    def save_wav_file(self, audio_data, output_path="output.wav"):
        """Save audio data as a WAV file."""
        if not audio_data:
            return None
            
        # Create WAV data
        wav_data = self.create_wav_data(audio_data)
        
        # Save to file
        with open(output_path, "wb") as f:
            f.write(wav_data)
            
        return output_path
    
    def get_or_generate_audio(self, text, speaker_id=None, cache_key=None):
        """Get audio from cache or generate new."""
        if not cache_key:
            cache_key = f"{text}_{speaker_id if speaker_id else ''}".replace(" ", "_")
            
        # Check cache first
        if cache_key in self.audio_cache:
            print(f"Using cached audio for: {text}")
            return self.create_wav_data(self.audio_cache[cache_key])
            
        # Generate new audio
        print(f"Generating new audio for: {text}")
        audio_data = self.generate_tts(text, speaker_id)
        
        # Store in cache
        if audio_data:
            self.audio_cache[cache_key] = audio_data
            
            # Limit cache size (keep most recent 20 items)
            if len(self.audio_cache) > 20:
                oldest_key = next(iter(self.audio_cache))
                del self.audio_cache[oldest_key]
                
        return self.create_wav_data(audio_data)
    
    def clear_cache(self):
        """Clear the audio cache."""
        self.audio_cache.clear()
        print("Audio cache cleared")

# HTTP handler for API requests
class TTSRequestHandler(BaseHTTPRequestHandler):
    tts_client = None  # Will be set later
    
    def do_GET(self):
        """Handle GET requests."""
        parsed_url = urlparse(self.path)
        path = parsed_url.path
        query = parse_qs(parsed_url.query)
        
        # Health check endpoint
        if path == "/health":
            self.send_response(200)
            self.send_header("Content-type", "text/plain")
            self.end_headers()
            self.wfile.write(b"OK")
            return
            
        # TTS endpoint
        if path == "/api/tts":
            # Get text parameter
            if "text" not in query:
                self.send_response(400)
                self.send_header("Content-type", "text/plain")
                self.end_headers()
                self.wfile.write(b"Missing 'text' parameter")
                return
                
            text = query["text"][0]
            speaker_id = query.get("reference_audio", [None])[0]
            
            print(f"TTS Request: '{text}' (ref: {speaker_id})")
            
            # Generate audio
            audio_data = self.tts_client.get_or_generate_audio(text, speaker_id)
            
            if not audio_data:
                self.send_response(500)
                self.send_header("Content-type", "text/plain")
                self.end_headers()
                self.wfile.write(b"Failed to generate audio")
                return
                
            # Send audio data
            self.send_response(200)
            self.send_header("Content-type", "audio/wav")
            self.send_header("Content-Length", str(len(audio_data)))
            self.end_headers()
            self.wfile.write(audio_data)
            print(f"Sent {len(audio_data)} bytes of WAV data")
            return
            
        # Clear cache endpoint
        if path == "/api/clear-cache":
            self.tts_client.clear_cache()
            self.send_response(200)
            self.send_header("Content-type", "text/plain")
            self.end_headers()
            self.wfile.write(b"Cache cleared")
            return
            
        # Default response for unknown endpoints
        self.send_response(404)
        self.send_header("Content-type", "text/plain")
        self.end_headers()
        self.wfile.write(b"Not Found")
    
    def log_message(self, format, *args):
        """Override to provide better logging."""
        print(f"[HTTP] {self.client_address[0]} - {format % args}")

def run_http_server(host, port, tts_client):
    """Run the HTTP server."""
    TTSRequestHandler.tts_client = tts_client
    server = HTTPServer((host, port), TTSRequestHandler)
    print(f"Starting HTTP server at http://{host}:{port}")
    print("Endpoints:")
    print("  - GET /health - Check server status")
    print("  - GET /api/tts?text=Hello%20world - Generate TTS audio")
    print("  - GET /api/clear-cache - Clear audio cache")
    
    try:
        server.serve_forever()
    except KeyboardInterrupt:
        print("\nShutting down server...")
        server.server_close()

def main():
    parser = argparse.ArgumentParser(description="F5-TTS Client with HTTP API")
    parser.add_argument("--socket-host", default="127.0.0.1", help="F5-TTS Socket server host")
    parser.add_argument("--socket-port", type=int, default=9000, help="F5-TTS Socket server port")
    parser.add_argument("--api-host", default="127.0.0.1", help="HTTP API host")
    parser.add_argument("--api-port", type=int, default=7860, help="HTTP API port")
    parser.add_argument("--text", help="Text to synthesize (CLI mode)")
    parser.add_argument("--output", help="Output WAV file (CLI mode)")
    args = parser.parse_args()
    
    # Create the TTS client
    tts_client = TTSSocketClient(args.socket_host, args.socket_port)
    
    # CLI mode - generate a single audio file
    if args.text:
        output_file = args.output or "output.wav"
        audio_data = tts_client.generate_tts(args.text)
        if audio_data:
            output_path = tts_client.save_wav_file(audio_data, output_file)
            print(f"Audio saved to: {os.path.abspath(output_path)}")
        return
    
    # API server mode - run HTTP server
    try:
        run_http_server(args.api_host, args.api_port, tts_client)
    except KeyboardInterrupt:
        print("Server stopped")

if __name__ == "__main__":
    main()